<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/jjing-neuro/feed/by_tag/Neuroscience.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/jjing-neuro/" rel="alternate" type="text/html" /><updated>2025-05-10T15:55:05+02:00</updated><id>http://localhost:4000/jjing-neuro/feed/by_tag/Neuroscience.xml</id><title type="html">Jim Jing</title><subtitle>A personal academic website focusing on neuroscience research and artificial intelligence</subtitle><entry><title type="html">Advanced Neural Signal Processing Techniques</title><link href="http://localhost:4000/jjing-neuro/blog/neural-signal-processing" rel="alternate" type="text/html" title="Advanced Neural Signal Processing Techniques" /><published>2024-03-22T00:00:00+01:00</published><updated>2024-03-22T00:00:00+01:00</updated><id>http://localhost:4000/jjing-neuro/blog/neural-signal-processing</id><content type="html" xml:base="http://localhost:4000/jjing-neuro/blog/neural-signal-processing"><![CDATA[<h1 id="advanced-neural-signal-processing-techniques">Advanced Neural Signal Processing Techniques</h1>

<p>Neural signal processing is fundamental to understanding brain function and developing neural interfaces. This post explores advanced techniques for processing and analyzing neural signals.</p>

<h2 id="wavelet-analysis">Wavelet Analysis</h2>

<p>Wavelets are particularly useful for analyzing time-frequency characteristics of neural signals:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pywt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">wavelet_analysis</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">):</span>
    <span class="s">"""Perform wavelet analysis on neural signals"""</span>
    <span class="c1"># Choose wavelet type and levels
</span>    <span class="n">wavelet</span> <span class="o">=</span> <span class="s">'db4'</span>
    <span class="n">levels</span> <span class="o">=</span> <span class="mi">5</span>
    
    <span class="c1"># Perform wavelet decomposition
</span>    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">pywt</span><span class="p">.</span><span class="n">wavedec</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">wavelet</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">levels</span><span class="p">)</span>
    
    <span class="c1"># Reconstruct signals at each level
</span>    <span class="n">reconstructed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">levels</span><span class="p">):</span>
        <span class="n">coeff_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">]</span>
        <span class="n">coeff_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">reconstructed</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">pywt</span><span class="p">.</span><span class="n">waverec</span><span class="p">(</span><span class="n">coeff_list</span><span class="p">,</span> <span class="n">wavelet</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">reconstructed</span>

<span class="c1"># Example usage
</span><span class="k">def</span> <span class="nf">plot_wavelet_decomposition</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">):</span>
    <span class="n">reconstructed</span> <span class="o">=</span> <span class="n">wavelet_analysis</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span> <span class="o">/</span> <span class="n">sampling_rate</span>
    
    <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reconstructed</span><span class="p">):</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reconstructed</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">rec</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s">'Level </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s"> Decomposition'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="advanced-filtering-techniques">Advanced Filtering Techniques</h2>

<p>Implementation of advanced filtering methods for neural signals:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

<span class="k">def</span> <span class="nf">design_filters</span><span class="p">():</span>
    <span class="s">"""Design various types of filters for neural signal processing"""</span>
    
    <span class="k">def</span> <span class="nf">notch_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
        <span class="s">"""Notch filter for removing power line noise"""</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">iirnotch</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span><span class="p">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">bandpass_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">low_freq</span><span class="p">,</span> <span class="n">high_freq</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="s">"""Bandpass filter for isolating frequency bands of interest"""</span>
        <span class="n">nyq</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">low</span> <span class="o">=</span> <span class="n">low_freq</span> <span class="o">/</span> <span class="n">nyq</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">high_freq</span> <span class="o">/</span> <span class="n">nyq</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="p">[</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">'band'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span><span class="p">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">savitzky_golay_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_length</span><span class="p">,</span> <span class="n">polyorder</span><span class="p">):</span>
        <span class="s">"""Savitzky-Golay filter for smoothing while preserving high moments"""</span>
        <span class="k">return</span> <span class="n">signal</span><span class="p">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_length</span><span class="p">,</span> <span class="n">polyorder</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">notch_filter</span><span class="p">,</span> <span class="n">bandpass_filter</span><span class="p">,</span> <span class="n">savitzky_golay_filter</span>
</code></pre></div></div>

<h2 id="feature-extraction">Feature Extraction</h2>

<p>Common feature extraction methods for neural signals:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_features</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
    <span class="s">"""Extract common features from neural signals"""</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># Time domain features
</span>    <span class="n">features</span><span class="p">[</span><span class="s">'mean'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">features</span><span class="p">[</span><span class="s">'std'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">features</span><span class="p">[</span><span class="s">'var'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">var</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">features</span><span class="p">[</span><span class="s">'rms'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">signal</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    
    <span class="c1"># Frequency domain features
</span>    <span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">welch</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
    <span class="n">features</span><span class="p">[</span><span class="s">'peak_freq'</span><span class="p">]</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">psd</span><span class="p">)]</span>
    <span class="n">features</span><span class="p">[</span><span class="s">'mean_freq'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">freqs</span> <span class="o">*</span> <span class="n">psd</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
    
    <span class="c1"># Entropy
</span>    <span class="n">features</span><span class="p">[</span><span class="s">'sample_entropy'</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_sample_entropy</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">features</span>

<span class="k">def</span> <span class="nf">compute_sample_entropy</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
    <span class="s">"""Compute sample entropy of the signal"""</span>
    <span class="c1"># Implementation of sample entropy calculation
</span>    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">count_matches</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">template</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Subtract self-match
</span>    
    <span class="c1"># Count matches for m and m+1 length templates
</span>    <span class="n">B</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">count_matches</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">m</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">A</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">count_matches</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">m</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">A</span><span class="o">/</span><span class="n">B</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="artifact-removal">Artifact Removal</h2>

<p>Implementation of ICA-based artifact removal:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">FastICA</span>

<span class="k">def</span> <span class="nf">remove_artifacts_ica</span><span class="p">(</span><span class="n">eeg_data</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">"""Remove artifacts using Independent Component Analysis"""</span>
    <span class="c1"># Reshape data if needed
</span>    <span class="k">if</span> <span class="n">eeg_data</span><span class="p">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># trials x channels x time
</span>        <span class="n">trials</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">eeg_data</span><span class="p">.</span><span class="n">shape</span>
        <span class="n">eeg_data</span> <span class="o">=</span> <span class="n">eeg_data</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">trials</span> <span class="o">*</span> <span class="n">samples</span><span class="p">,</span> <span class="n">channels</span><span class="p">)</span>
    
    <span class="c1"># Apply ICA
</span>    <span class="n">ica</span> <span class="o">=</span> <span class="n">FastICA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">ica</span><span class="p">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">eeg_data</span><span class="p">)</span>
    
    <span class="c1"># Here you would typically identify artifact components
</span>    <span class="c1"># This is often done through visual inspection or automated methods
</span>    
    <span class="c1"># Reconstruct signal without artifact components
</span>    <span class="n">cleaned_data</span> <span class="o">=</span> <span class="n">ica</span><span class="p">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">cleaned_data</span>
</code></pre></div></div>

<h2 id="advanced-connectivity-analysis">Advanced Connectivity Analysis</h2>

<p>Modern neural signal analysis often involves studying connectivity between different brain regions:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compute_connectivity</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'plv'</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">256</span><span class="p">):</span>
    <span class="s">"""Compute various connectivity measures between signals"""</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">'plv'</span><span class="p">:</span>
        <span class="c1"># Phase Locking Value
</span>        <span class="k">def</span> <span class="nf">compute_plv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">analytic_x</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">analytic_y</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">phase_diff</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_y</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1j</span> <span class="o">*</span> <span class="n">phase_diff</span><span class="p">)))</span>
        
        <span class="n">n_channels</span> <span class="o">=</span> <span class="n">signals</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">):</span>
                <span class="n">plv</span> <span class="o">=</span> <span class="n">compute_plv</span><span class="p">(</span><span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">signals</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">connectivity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">plv</span>
                <span class="n">connectivity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">plv</span>
                
        <span class="k">return</span> <span class="n">connectivity</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">'coherence'</span><span class="p">:</span>
        <span class="c1"># Magnitude Squared Coherence
</span>        <span class="n">n_channels</span> <span class="o">=</span> <span class="n">signals</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">):</span>
                <span class="n">f</span><span class="p">,</span> <span class="n">coh</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">coherence</span><span class="p">(</span><span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">signals</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
                <span class="n">connectivity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coh</span><span class="p">)</span>
                <span class="n">connectivity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                
        <span class="k">return</span> <span class="n">connectivity</span>

<span class="k">def</span> <span class="nf">plot_connectivity</span><span class="p">(</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">):</span>
    <span class="s">"""Plot connectivity matrix as a heatmap"""</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'viridis'</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s">'equal'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">'Connectivity Strength'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_names</span><span class="p">)),</span> <span class="n">channel_names</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">yticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_names</span><span class="p">)),</span> <span class="n">channel_names</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Brain Connectivity Matrix'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="advanced-time-series-analysis">Advanced Time-Series Analysis</h2>

<p>Implementation of advanced time series analysis methods:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compute_multiscale_entropy</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">scales</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.15</span><span class="p">):</span>
    <span class="s">"""Compute Multiscale Entropy"""</span>
    <span class="k">def</span> <span class="nf">coarse_grain</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="s">"""Coarse-graining for multiscale entropy"""</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">coarse</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">scale</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
            <span class="n">coarse</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="n">scale</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">scale</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">coarse</span>
    
    <span class="c1"># Normalize signal
</span>    <span class="n">signal</span> <span class="o">=</span> <span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">mse</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">scales</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scales</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">coarse_signal</span> <span class="o">=</span> <span class="n">coarse_grain</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">mse</span><span class="p">[</span><span class="n">scale</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_sample_entropy</span><span class="p">(</span><span class="n">coarse_signal</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">mse</span>

<span class="k">def</span> <span class="nf">detrended_fluctuation_analysis</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">scales</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">"""Perform Detrended Fluctuation Analysis"""</span>
    <span class="k">if</span> <span class="n">scales</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">scales</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">//</span><span class="mi">4</span><span class="p">),</span> <span class="mi">20</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="c1"># Calculate profile
</span>    <span class="n">profile</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
    
    <span class="n">fluctuations</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scales</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scales</span><span class="p">):</span>
        <span class="c1"># Split signal into windows
</span>        <span class="n">n_windows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span> <span class="o">//</span> <span class="n">scale</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">profile</span><span class="p">[:</span><span class="n">n_windows</span><span class="o">*</span><span class="n">scale</span><span class="p">],</span> <span class="n">n_windows</span><span class="p">)</span>
        
        <span class="c1"># Calculate local trend and fluctuation
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">fluct</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_windows</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">window</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">windows</span><span class="p">):</span>
            <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">trend</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">fluct</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">((</span><span class="n">window</span> <span class="o">-</span> <span class="n">trend</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            
        <span class="n">fluctuations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fluct</span><span class="p">)</span>
    
    <span class="c1"># Calculate scaling exponent
</span>    <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">scales</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scales</span><span class="p">,</span> <span class="n">fluctuations</span><span class="p">,</span> <span class="n">coef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="non-linear-dynamics-analysis">Non-linear Dynamics Analysis</h2>

<p>Tools for analyzing non-linear dynamics in neural signals:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recurrence_plot</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="s">"""Generate a recurrence plot from time series data"""</span>
    <span class="c1"># Time delay embedding
</span>    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">delay</span>
    <span class="n">phase_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">dimension</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
        <span class="n">phase_space</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">delay</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="n">delay</span> <span class="o">+</span> <span class="n">N</span><span class="p">]</span>
    
    <span class="c1"># Calculate distances
</span>    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">phase_space</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">phase_space</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    
    <span class="c1"># Create recurrence matrix
</span>    <span class="n">recurrence</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">&lt;</span> <span class="n">threshold</span>
    
    <span class="k">return</span> <span class="n">recurrence</span>

<span class="k">def</span> <span class="nf">lyapunov_exponent</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="s">"""Estimate the largest Lyapunov exponent"""</span>
    <span class="c1"># Phase space reconstruction
</span>    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">delay</span>
    <span class="n">phase_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">dimension</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
        <span class="n">phase_space</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">delay</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="n">delay</span> <span class="o">+</span> <span class="n">N</span><span class="p">]</span>
    
    <span class="c1"># Find nearest neighbors
</span>    <span class="n">divergences</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">phase_space</span> <span class="o">-</span> <span class="n">phase_space</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">nearest</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Exclude self
</span>        
        <span class="c1"># Track divergence
</span>        <span class="n">divergences</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">signal</span><span class="p">[</span><span class="n">nearest</span><span class="p">]))</span> <span class="o">/</span> <span class="n">dt</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">divergences</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>These advanced signal processing techniques form the foundation for modern neural signal analysis. They enable researchers to extract meaningful information from complex neural recordings and develop more sophisticated brain-computer interfaces.</p>

<h2 id="references">References</h2>

<ol>
  <li>Cohen, M. X. (2014). Analyzing Neural Time Series Data: Theory and Practice.</li>
  <li>Makeig, S., et al. (2004). Mining event-related brain dynamics.</li>
  <li>Quiroga, R. Q., et al. (2004). Independent component analysis for neural signal processing.</li>
</ol>]]></content><author><name></name></author><category term="blog" /><category term="Signal Processing" /><category term="Neuroscience" /><category term="Python" /><summary type="html"><![CDATA[A deep dive into modern neural signal processing methods with practical Python implementations]]></summary></entry><entry><title type="html">Introduction to EEG Analysis with Python</title><link href="http://localhost:4000/jjing-neuro/blog/introduction-to-eeg-analysis" rel="alternate" type="text/html" title="Introduction to EEG Analysis with Python" /><published>2024-03-20T00:00:00+01:00</published><updated>2024-03-20T00:00:00+01:00</updated><id>http://localhost:4000/jjing-neuro/blog/introduction-to-eeg-analysis</id><content type="html" xml:base="http://localhost:4000/jjing-neuro/blog/introduction-to-eeg-analysis"><![CDATA[<h1 id="introduction-to-eeg-analysis-with-python">Introduction to EEG Analysis with Python</h1>

<p>Electroencephalography (EEG) is a powerful tool for studying brain activity. In this tutorial, we’ll explore how to analyze EEG data using Python and the popular MNE library.</p>

<h2 id="setting-up-your-environment">Setting Up Your Environment</h2>

<p>First, let’s set up our Python environment with the necessary packages:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># For data visualization
</span><span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</code></pre></div></div>

<h2 id="loading-and-preprocessing-eeg-data">Loading and Preprocessing EEG Data</h2>

<p>Here’s a basic example of loading and preprocessing EEG data:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Load example data
</span><span class="n">sample_data_folder</span> <span class="o">=</span> <span class="n">mne</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">sample</span><span class="p">.</span><span class="n">data_path</span><span class="p">()</span>
<span class="n">raw_fname</span> <span class="o">=</span> <span class="n">sample_data_folder</span> <span class="o">+</span> <span class="s">'/MEG/sample/sample_audvis_raw.fif'</span>
<span class="n">raw</span> <span class="o">=</span> <span class="n">mne</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">read_raw_fif</span><span class="p">(</span><span class="n">raw_fname</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Basic preprocessing
</span><span class="n">raw</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>  <span class="c1"># Band-pass filter from 1-40 Hz
</span><span class="n">raw</span><span class="p">.</span><span class="n">notch_filter</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>  <span class="c1"># Remove power line noise
</span></code></pre></div></div>

<h2 id="analyzing-eeg-data">Analyzing EEG Data</h2>

<p>Let’s look at some basic analysis techniques:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create epochs
</span><span class="n">events</span> <span class="o">=</span> <span class="n">mne</span><span class="p">.</span><span class="n">find_events</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="n">mne</span><span class="p">.</span><span class="n">Epochs</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=-</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Calculate and plot evoked response
</span><span class="n">evoked</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">.</span><span class="n">average</span><span class="p">()</span>
<span class="n">evoked</span><span class="p">.</span><span class="n">plot</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="time-frequency-analysis">Time-Frequency Analysis</h2>

<p>Here’s how to perform time-frequency analysis:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">power</span> <span class="o">=</span> <span class="n">mne</span><span class="p">.</span><span class="n">time_frequency</span><span class="p">.</span><span class="n">tfr_morlet</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> 
                                    <span class="n">n_cycles</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_itc</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">power</span><span class="p">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
</code></pre></div></div>

<h2 id="eeg-band-analysis">EEG Band Analysis</h2>

<p>A crucial part of EEG analysis is examining different frequency bands:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">analyze_frequency_bands</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="p">[</span><span class="s">'Fz'</span><span class="p">,</span> <span class="s">'Cz'</span><span class="p">,</span> <span class="s">'Pz'</span><span class="p">]):</span>
    <span class="s">"""Analyze standard EEG frequency bands"""</span>
    <span class="c1"># Define frequency bands
</span>    <span class="n">bands</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'Delta'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="s">'Theta'</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="s">'Alpha'</span><span class="p">:</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
        <span class="s">'Beta'</span><span class="p">:</span> <span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
        <span class="s">'Gamma'</span><span class="p">:</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1"># Calculate power spectral density
</span>    <span class="n">psds</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mne</span><span class="p">.</span><span class="n">time_frequency</span><span class="p">.</span><span class="n">psd_welch</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> 
                                              <span class="n">fmin</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                                              <span class="n">fmax</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span>
                                              <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">)</span>
    
    <span class="c1"># Calculate band power
</span>    <span class="n">band_powers</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">band</span><span class="p">,</span> <span class="p">(</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">freq_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="n">fmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&lt;=</span> <span class="n">fmax</span><span class="p">)</span>
        <span class="n">band_powers</span><span class="p">[</span><span class="n">band</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psds</span><span class="p">[:,</span> <span class="n">freq_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">band_powers</span>

<span class="c1"># Example visualization
</span><span class="k">def</span> <span class="nf">plot_band_powers</span><span class="p">(</span><span class="n">band_powers</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">):</span>
    <span class="s">"""Plot power in different frequency bands"""</span>
    <span class="n">bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">band_powers</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_names</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">))</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">/</span> <span class="n">channels</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_names</span><span class="p">):</span>
        <span class="n">powers</span> <span class="o">=</span> <span class="p">[</span><span class="n">band_powers</span><span class="p">[</span><span class="n">band</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span> <span class="n">powers</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Frequency Bands'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Power (µV²/Hz)'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'EEG Band Powers'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="p">(</span><span class="n">channels</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">bands</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="data-quality-assessment">Data Quality Assessment</h2>

<p>Before detailed analysis, it’s important to assess data quality:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">check_data_quality</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
    <span class="s">"""Basic data quality checks"""</span>
    <span class="c1"># Check for flat signals
</span>    <span class="n">flat_channels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ch_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">.</span><span class="n">ch_names</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">raw</span><span class="p">.</span><span class="n">_data</span><span class="p">[</span><span class="n">ch_idx</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="n">flat_channels</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">raw</span><span class="p">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">ch_idx</span><span class="p">])</span>
    
    <span class="c1"># Check for noisy channels
</span>    <span class="n">noisy_channels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">zscore_thresh</span> <span class="o">=</span> <span class="mf">4.0</span>
    <span class="k">for</span> <span class="n">ch_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">.</span><span class="n">ch_names</span><span class="p">)):</span>
        <span class="n">z_scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">zscore</span><span class="p">(</span><span class="n">raw</span><span class="p">.</span><span class="n">_data</span><span class="p">[</span><span class="n">ch_idx</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nb">any</span><span class="p">(</span><span class="n">z_scores</span> <span class="o">&gt;</span> <span class="n">zscore_thresh</span><span class="p">):</span>
            <span class="n">noisy_channels</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">raw</span><span class="p">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">ch_idx</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s">'flat_channels'</span><span class="p">:</span> <span class="n">flat_channels</span><span class="p">,</span>
        <span class="s">'noisy_channels'</span><span class="p">:</span> <span class="n">noisy_channels</span><span class="p">,</span>
        <span class="s">'total_channels'</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">.</span><span class="n">ch_names</span><span class="p">),</span>
        <span class="s">'duration'</span><span class="p">:</span> <span class="n">raw</span><span class="p">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="s">'sampling_rate'</span><span class="p">:</span> <span class="n">raw</span><span class="p">.</span><span class="n">info</span><span class="p">[</span><span class="s">'sfreq'</span><span class="p">]</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>This introduction covers the basics of EEG analysis with Python. In future posts, we’ll explore more advanced topics like source localization and connectivity analysis.</p>

<h2 id="references">References</h2>

<ol>
  <li>Gramfort, A., et al. (2013). MEG and EEG data analysis with MNE-Python. Frontiers in Neuroscience.</li>
  <li>Cohen, M. X. (2014). Analyzing Neural Time Series Data: Theory and Practice.</li>
</ol>]]></content><author><name></name></author><category term="blog" /><category term="EEG" /><category term="Python" /><category term="Neuroscience" /><summary type="html"><![CDATA[A comprehensive guide to getting started with EEG data analysis using Python and MNE library]]></summary></entry></feed>