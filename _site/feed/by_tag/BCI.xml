<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/jjing-neuro/feed/by_tag/BCI.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/jjing-neuro/" rel="alternate" type="text/html" /><updated>2025-05-10T15:50:13+02:00</updated><id>http://localhost:4000/jjing-neuro/feed/by_tag/BCI.xml</id><title type="html">Jim Jing</title><subtitle>A personal academic website focusing on neuroscience research and artificial intelligence</subtitle><entry><title type="html">Recent Advances in Brain-Computer Interfaces</title><link href="http://localhost:4000/jjing-neuro/blog/brain-computer-interfaces" rel="alternate" type="text/html" title="Recent Advances in Brain-Computer Interfaces" /><published>2024-03-21T00:00:00+01:00</published><updated>2024-03-21T00:00:00+01:00</updated><id>http://localhost:4000/jjing-neuro/blog/brain-computer-interfaces</id><content type="html" xml:base="http://localhost:4000/jjing-neuro/blog/brain-computer-interfaces"><![CDATA[<h1 id="recent-advances-in-brain-computer-interfaces">Recent Advances in Brain-Computer Interfaces</h1>

<p>Brain-Computer Interfaces (BCIs) represent one of the most exciting frontiers in neuroscience and neural engineering. This post explores recent developments and their implications for research and clinical applications.</p>

<h2 id="modern-bci-architectures">Modern BCI Architectures</h2>

<p>Here’s a simple example of a modern BCI classification pipeline using Python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.discriminant_analysis</span> <span class="kn">import</span> <span class="n">LinearDiscriminantAnalysis</span>

<span class="k">def</span> <span class="nf">create_bci_pipeline</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Pipeline</span><span class="p">([</span>
        <span class="p">(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
        <span class="p">(</span><span class="s">'classifier'</span><span class="p">,</span> <span class="n">LinearDiscriminantAnalysis</span><span class="p">())</span>
    <span class="p">])</span>

<span class="c1"># Example usage with EEG features
</span><span class="k">def</span> <span class="nf">process_eeg_data</span><span class="p">(</span><span class="n">eeg_data</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="c1"># Assume eeg_data is a matrix of shape (n_trials, n_channels, n_timepoints)
</span>    <span class="c1"># Extract features (e.g., band powers)
</span>    <span class="n">features</span> <span class="o">=</span> <span class="n">extract_features</span><span class="p">(</span><span class="n">eeg_data</span><span class="p">)</span>
    
    <span class="c1"># Create and train the pipeline
</span>    <span class="n">bci_pipeline</span> <span class="o">=</span> <span class="n">create_bci_pipeline</span><span class="p">()</span>
    <span class="n">bci_pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">bci_pipeline</span>
</code></pre></div></div>

<h2 id="deep-learning-in-bci">Deep Learning in BCI</h2>

<p>Modern BCIs increasingly utilize deep learning approaches:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>

<span class="k">class</span> <span class="nc">EEGNet</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EEGNet</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s">'same'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">AvgPool2d</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="mi">61</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">bn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">pool</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">fc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="real-time-signal-processing">Real-time Signal Processing</h2>

<p>Essential components of real-time BCI systems:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

<span class="k">def</span> <span class="nf">real_time_preprocessing</span><span class="p">(</span><span class="n">eeg_chunk</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="mi">250</span><span class="p">):</span>
    <span class="s">"""Real-time preprocessing of EEG data"""</span>
    <span class="c1"># Notch filter
</span>    <span class="n">notch_freq</span> <span class="o">=</span> <span class="mf">50.0</span>  <span class="c1"># Hz
</span>    <span class="n">quality_factor</span> <span class="o">=</span> <span class="mf">30.0</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">iirnotch</span><span class="p">(</span><span class="n">notch_freq</span><span class="p">,</span> <span class="n">quality_factor</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">)</span>
    <span class="n">eeg_notched</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">eeg_chunk</span><span class="p">)</span>
    
    <span class="c1"># Bandpass filter
</span>    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s">'bandpass'</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sfreq</span><span class="p">)</span>
    <span class="n">eeg_filtered</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">eeg_notched</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">eeg_filtered</span>
</code></pre></div></div>

<h2 id="future-directions">Future Directions</h2>

<p>The field of BCI is rapidly evolving with new developments in:</p>
<ul>
  <li>High-resolution neural interfaces</li>
  <li>Adaptive learning algorithms</li>
  <li>Wireless and portable systems</li>
  <li>Enhanced user feedback mechanisms</li>
</ul>

<h2 id="clinical-applications">Clinical Applications</h2>

<p>BCIs are increasingly being used in clinical settings for:</p>
<ul>
  <li>Motor rehabilitation</li>
  <li>Communication aids</li>
  <li>Prosthetic control</li>
  <li>Neurological disorder treatment</li>
</ul>

<h2 id="recent-research-breakthroughs">Recent Research Breakthroughs</h2>

<h3 id="closed-loop-systems">Closed-Loop Systems</h3>
<p>Modern BCIs are moving towards closed-loop systems that provide real-time feedback:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ClosedLoopBCI</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">256</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sampling_rate</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 2-second buffer
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">signal_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">32</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">buffer_size</span><span class="p">))</span>  <span class="c1"># 32 channels
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">feedback_threshold</span> <span class="o">=</span> <span class="mf">0.75</span>
        
    <span class="k">def</span> <span class="nf">process_chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
        <span class="s">"""Process new data chunk and provide feedback"""</span>
        <span class="c1"># Update buffer
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">signal_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">signal_buffer</span><span class="p">,</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">signal_buffer</span><span class="p">[:,</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="p">):]</span> <span class="o">=</span> <span class="n">new_data</span>
        
        <span class="c1"># Extract features
</span>        <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">extract_features</span><span class="p">()</span>
        
        <span class="c1"># Classify and generate feedback
</span>        <span class="n">prediction</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">classify</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
        <span class="n">feedback</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">generate_feedback</span><span class="p">(</span><span class="n">prediction</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">feedback</span>
    
    <span class="k">def</span> <span class="nf">extract_features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Extract relevant features from the buffer"""</span>
        <span class="c1"># Example feature extraction
</span>        <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">signal_buffer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">classify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">):</span>
        <span class="s">"""Classify current state"""</span>
        <span class="c1"># Example classification
</span>        <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">feedback_threshold</span>
    
    <span class="k">def</span> <span class="nf">generate_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prediction</span><span class="p">):</span>
        <span class="s">"""Generate appropriate feedback based on classification"""</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s">'stimulation'</span><span class="p">:</span> <span class="n">prediction</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>  <span class="c1"># Example: 50% stimulation if positive
</span>            <span class="s">'visual_feedback'</span><span class="p">:</span> <span class="s">'green'</span> <span class="k">if</span> <span class="n">prediction</span> <span class="k">else</span> <span class="s">'red'</span><span class="p">,</span>
            <span class="s">'timestamp'</span><span class="p">:</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
        <span class="p">}</span>
</code></pre></div></div>

<h3 id="advanced-decoding-algorithms">Advanced Decoding Algorithms</h3>

<p>Recent advances in deep learning have enabled more sophisticated decoding:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TransformerBCI</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">n_timepoints</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">n_classes</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n_channels</span> <span class="o">=</span> <span class="n">n_channels</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n_timepoints</span> <span class="o">=</span> <span class="n">n_timepoints</span>
        
        <span class="c1"># Temporal embedding
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">temporal_embed</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">n_timepoints</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
        
        <span class="c1"># Transformer encoder
</span>        <span class="n">encoder_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">TransformerEncoderLayer</span><span class="p">(</span>
            <span class="n">d_model</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
            <span class="n">nhead</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
            <span class="n">dim_feedforward</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
            <span class="n">dropout</span><span class="o">=</span><span class="mf">0.1</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">transformer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">TransformerEncoder</span><span class="p">(</span><span class="n">encoder_layer</span><span class="p">,</span> <span class="n">num_layers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="c1"># Classification head
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">128</span> <span class="o">*</span> <span class="n">n_channels</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="n">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">)</span>
        <span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># x shape: (batch, channels, timepoints)
</span>        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">temporal_embed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (batch, channels, 128)
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># (channels, batch, 128)
</span>        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">transformer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (channels, batch, 128)
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># (batch, channels, 128)
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (batch, channels * 128)
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">classifier</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="multimodal-integration">Multimodal Integration</h3>

<p>Modern BCIs often combine multiple signal types:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MultimodalBCI</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">eeg_model</span> <span class="o">=</span> <span class="n">EEGNet</span><span class="p">(</span><span class="n">n_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">n_classes</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">emg_model</span> <span class="o">=</span> <span class="n">EMGNet</span><span class="p">(</span><span class="n">n_channels</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">n_classes</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fusion_model</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">create_fusion_model</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">create_fusion_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nn</span><span class="p">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>  <span class="c1"># 4 classes from each modality
</span>            <span class="n">nn</span><span class="p">.</span><span class="n">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="n">Softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eeg_data</span><span class="p">,</span> <span class="n">emg_data</span><span class="p">):</span>
        <span class="n">eeg_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">eeg_model</span><span class="p">(</span><span class="n">eeg_data</span><span class="p">)</span>
        <span class="n">emg_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">emg_model</span><span class="p">(</span><span class="n">emg_data</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">cat</span><span class="p">([</span><span class="n">eeg_pred</span><span class="p">,</span> <span class="n">emg_pred</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">fusion_model</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="future-perspectives">Future Perspectives</h2>

<p>The field continues to evolve with promising developments in:</p>
<ul>
  <li>High-density neural interfaces</li>
  <li>Wireless and miniaturized systems</li>
  <li>Advanced machine learning algorithms</li>
  <li>Enhanced user experience and feedback</li>
  <li>Integration with other assistive technologies</li>
</ul>

<h2 id="references">References</h2>

<ol>
  <li>Wolpaw, J., &amp; Wolpaw, E. W. (Eds.). (2012). Brain-computer interfaces: principles and practice.</li>
  <li>Craik, A., et al. (2019). Deep learning for electroencephalogram (EEG) classification tasks: a review.</li>
  <li>Schwemmer, M. A., et al. (2018). Meeting brain–computer interface user performance expectations.</li>
</ol>]]></content><author><name></name></author><category term="blog" /><category term="BCI" /><category term="Neural Engineering" /><category term="Machine Learning" /><summary type="html"><![CDATA[An overview of recent developments in BCI technology and their applications in neuroscience research]]></summary></entry></feed>